
	stdio.h
	readline/readline.h
	readline/history.h
		https://web.mit.edu/gnu/doc/html/rlman_2.html
		readline
			Reads a line from the terminal and returns it, using prompt as prompt.
			The line returned is allocated with malloc, the caller must free it
			when finished.
				A blank line returns the empty string.
				if EOF is found and the line is empty, NULL is returned.
				if EOF is found and the line is NOT empty, it is treated as a newline.
		add_history
			manages string. Already works plressing uparrow downarrow.	
		rl_clear_history
			Clear the history list by deleting all of the entries.
		rl_on_new_line
			
		rl_replace_line
			
		rl_redisplay
			"puts prompts again"

	stdio.h
		printf

	stdlib.h
		malloc
		exit
		getenv

	unistd.h
		free
		write
		access
		read
		close
		fork
		getcwd
		chdir
		unlink
		execve
		dup
			duplicates one file descryptor. Used mostly when dup2 is used in X Y
			and then loses the reference to those original fds.
			With dup you can save one fd to use later.
		dup2
		pipe
		isatty
		ttyname
		ttyslot

	fcntl.h
		open

	sys/wait.h
		wait
		waitpid
		wait3
		wait4

	sys/stat.h
		stat
		lstat
		fstat

	signal.h
		signal
		sigaction
		sigemptyset
		sigaddset
		kill

	sys/types.h
	dirent.h
		opendir
		closedir

	dirent.h
		readdir

	string.h
		strerror

	errno.h
		perror

	sys/ioctl.h
		ioctl

	termios.h
		tcsetattr
		tcgetattr
		tgetnum
		tgetstr
		tgoto
		tputs

	curses.h
	term.h
		tgetent
		tgetflag

Probably unused functions:
	wait, wait3, wait4
	stat, lstat, fstat, unlink, 
	tyname, ttyslot, ioctl,
	getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
	tgetnum, tgetstr, tgoto, tputs

If error message != bash no worries

Ctrl -D Interprets an empty prompt as NULL in readline

Cuando declaramos una variable de entorno, podemos pasarle como valor un conjunto de comandos
	que estaran entre parentesis. Deberemos ejecutar los comandos y el output final guardarlo como
	el valor de la variable Y NO PASARLO por STDOUT...
	ej: (df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_t += $2} END {printf ("%.1fGb\n"), disk_t/1024}')

1st arg
	Command
	<<(here_doc)

2nd
	Flag
	Arg / File / if (argv[1][0] == '$') environment variable
	<<(here_doc)
	Nothing

3rd +
	Flag
	Arg / File /  if (argv[1][0] == '$') environment variable
	<<(here_doc)
	Pipe
	Redirection

Implement
	>
	<
	>>
	<< (here_doc) DELIMITER must be after '<<'
	|

Parse
	""
	''
	$
