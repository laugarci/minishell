
	stdio.h
	readline/readline.h
	readline/history.h
		https://web.mit.edu/gnu/doc/html/rlman_2.html
		readline
			Reads a line from the terminal and returns it, using prompt as prompt.
			The line returned is allocated with malloc, the caller must free it
			when finished.
				A blank line returns the empty string.
				if EOF is found and the line is empty, NULL is returned.
				if EOF is found and the line is NOT empty, it is treated as a newline.
		add_history
			manages string. Already works plressing uparrow downarrow.	
		rl_clear_history
			Clear the history list by deleting all of the entries.
		rl_on_new_line
			
		rl_replace_line
			
		rl_redisplay
			"puts prompts again"

	stdio.h
		printf

	stdlib.h
		malloc
		exit
		getenv

	unistd.h
		free
		write
		access
		read
		close
		fork
		getcwd
		chdir
		unlink
		execve
		dup
			duplicates one file descryptor. Used mostly when dup2 is used in X Y
			and then loses the reference to those original fds.
			With dup you can save one fd to use later.
		dup2
		pipe
		isatty
		ttyname
		ttyslot

	fcntl.h
		open

	sys/wait.h
		wait
		waitpid
		wait3
		wait4

	sys/stat.h
		stat
		lstat
		fstat

	signal.h
		signal
		sigaction
		sigemptyset
		sigaddset
		kill

	sys/types.h
	dirent.h
		opendir
		closedir

	dirent.h
		readdir

	string.h
		strerror

	errno.h
		perror

	sys/ioctl.h
		ioctl

	termios.h
		tcsetattr
		tcgetattr
		tgetnum
		tgetstr
		tgoto
		tputs

	curses.h
	term.h
		tgetent
		tgetflag

Probably unused functions:
	wait, wait3, wait4
	stat, lstat, fstat, unlink, 
	tyname, ttyslot, ioctl,
	getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
	tgetnum, tgetstr, tgoto, tputs

If error message != bash no worries

Ctrl -D Interprets an empty prompt as NULL in readline

Cuando declaramos una variable de entorno, podemos pasarle como valor un conjunto de comandos
	que estaran entre parentesis SIEMPRE Y CUANDO los parentesis vayan precedidos del simbolo '$'
	Deberemos ejecutar los comandos y el output final guardarlo como el valor de la variable 
	Y NO PASARLO por STDOUT...
	Este conjunto de comandos podemos pasarlo justo despues de cualquier prompt que queramos y
	se mostrara primero el prompt y despues el resultado de los comandos.
	ej: $(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_t += $2} END {printf ("%.1fGb\n"), disk_t/1024}')

1st arg
	Command 
		// DONE <<(here_doc) // DONE
	$[VARIABLE] Expandir variable de entorno en mensaje de error a no ser, que la este declarando
	NOMBRE_DE_VARIABLE="VALOR_DE_VARIABLE" // Investigar si las variables de entorno deben usar export para hacer cosas

2nd
	Flag
	Arg / File / if (argv[1][0] == '$') environment variable
	"DONE" Implementado la funcion get_delimiter que busca el delimitador donde este, sin embargo debemos tener en cuenta que si este es el segundo argumento,  no es ni un archivo, ni una flag, ni cosas raras... << (here_doc) if (mi primer argumento es "<< " con el espacio incluido, mi segundo argumento es el delimitador)
	Nothing

3rd +
	Flag
	Arg / File /  if (argv[1][0] == '$') environment variable
	<<(here_doc)
	Pipe
	Redirection

Implement
	>
	<
	>>
	<< (here_doc) DELIMITER must be after '<<'
	|

Parse
	""
	''
	$

To declare env variables must use export first

LAURA:
		Recomanacions: Fes servir comandos sense flags, que rebin un argument ja sigui d'un pipe o d'un fd o
			del here_doc;
	Executar comandos
		access
		execve
	Gestionar pipes y file descriptors
		dup
		dup2
		pipe
		fork
		open
		read
		close
	
FERRAN:
	Parseo jeje
	Signals
		Ctrl C
		Ctrl D
		Ctrl \
